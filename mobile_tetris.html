<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Mobile Tetris</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: #000;
    overflow: hidden;
    touch-action: none;
  }
  canvas {
    display: block;
    background: #111;
  }
</style>
</head>
<body>
<canvas id="tetris"></canvas>
<script>
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
let width, height, blockSize;
function resize() {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
  blockSize = Math.floor(Math.min(width / COLS, height / ROWS));
}
window.addEventListener('resize', resize);

const COLS = 10;
const ROWS = 20;
const COLORS = [
  null,
  '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF',
  '#FF8E0D', '#FFE138', '#3877FF'
];
const SHAPES = [
  [],
  [[0,0,0],
   [1,1,1],
   [0,1,0]],
  [[0,2,0],
   [0,2,0],
   [0,2,2]],
  [[0,3,0],
   [0,3,0],
   [3,3,0]],
  [[4,4],
   [4,4]],
  [[0,5,5],
   [5,5,0],
   [0,0,0]],
  [[6,6,0],
   [0,6,6],
   [0,0,0]],
  [[0,0,0,0],
   [7,7,7,7],
   [0,0,0,0],
   [0,0,0,0]]
];

function createMatrix(w,h) {
  const m = [];
  while (h--) m.push(new Array(w).fill(0));
  return m;
}

function drawMatrix(matrix, offset) {
  matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if (value) {
        ctx.fillStyle = COLORS[value];
        ctx.fillRect((x+offset.x)*blockSize,(y+offset.y)*blockSize,blockSize-1,blockSize-1);
      }
    });
  });
}

function merge(arena, player) {
  player.matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if (value) {
        arena[y+player.pos.y][x+player.pos.x] = value;
      }
    });
  });
}

function collide(arena, player) {
  const m = player.matrix;
  const o = player.pos;
  for (let y=0;y<m.length;++y) {
    for (let x=0;x<m[y].length;++x) {
      if (m[y][x] &&
         (arena[y+o.y] &&
          arena[y+o.y][x+o.x]) !== 0) {
        return true;
      }
    }
  }
  return false;
}

function playerDrop() {
  while (!collide(arena, player)) {
    player.pos.y++;
  }
  player.pos.y--;
  merge(arena, player);
  playerReset();
  arenaSweep();
  dropCounter = 0;
}

function playerMove(dir) {
  player.pos.x += dir;
  if (collide(arena, player)) {
    player.pos.x -= dir;
  }
}

function playerReset() {
  const pieces = 'TJLOSZI';
  player.matrix = createPiece(pieces[pieces.length * Math.random() | 0]);
  player.pos.y = 0;
  player.pos.x = (COLS/2 | 0) - (player.matrix[0].length/2 | 0);
  if (collide(arena, player)) {
    arena.forEach(row=>row.fill(0));
  }
}

function playerRotate(dir) {
  const pos = player.pos.x;
  let offset = 1;
  rotate(player.matrix, dir);
  while (collide(arena, player)) {
    player.pos.x += offset;
    offset = -(offset + (offset>0?1:-1));
    if (offset > player.matrix[0].length) {
      rotate(player.matrix, -dir);
      player.pos.x = pos;
      return;
    }
  }
}

function rotate(matrix, dir) {
  for (let y=0;y<matrix.length;++y) {
    for (let x=0;x<y;++x) {
      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
    }
  }
  if (dir>0) matrix.forEach(row=>row.reverse());
  else matrix.reverse();
}

function createPiece(type) {
  if (type==='T') return SHAPES[1].map(r=>r.slice());
  if (type==='J') return SHAPES[2].map(r=>r.slice());
  if (type==='L') return SHAPES[3].map(r=>r.slice());
  if (type==='O') return SHAPES[4].map(r=>r.slice());
  if (type==='S') return SHAPES[5].map(r=>r.slice());
  if (type==='Z') return SHAPES[6].map(r=>r.slice());
  if (type==='I') return SHAPES[7].map(r=>r.slice());
}

function arenaSweep() {
  outer: for (let y=arena.length-1;y>=0;--y) {
    for (let x=0;x<arena[y].length;++x) {
      if (arena[y][x]===0) continue outer;
    }
    const row = arena.splice(y,1)[0].fill(0);
    arena.unshift(row);
    y++;
  }
}

let arena = createMatrix(COLS, ROWS);
let player = { pos: {x:0,y:0}, matrix: null };

let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;

function update(time=0) {
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if (dropCounter > dropInterval) {
    player.pos.y++;
    if (collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      playerReset();
      arenaSweep();
    }
    dropCounter = 0;
  }
  ctx.clearRect(0,0,width,height);
  drawMatrix(arena,{x:0,y:0});
  drawMatrix(player.matrix, player.pos);
  requestAnimationFrame(update);
}

playerReset();
resize();
update();

// Touch controls: swipe left/right/down, tap to rotate
let touchStartX=0, touchStartY=0, touchEndX=0, touchEndY=0;
let touchStartTime=0;
canvas.addEventListener('touchstart', e=>{
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
  touchEndX = touchStartX;
  touchEndY = touchStartY;
  touchStartTime = Date.now();
}, {passive:false});

canvas.addEventListener('touchmove', e=>{
  const t = e.touches[0];
  touchEndX = t.clientX;
  touchEndY = t.clientY;
}, {passive:false});

canvas.addEventListener('touchend', e=>{
  const dx = touchEndX - touchStartX;
  const dy = touchEndY - touchStartY;
  const adx = Math.abs(dx);
  const ady = Math.abs(dy);
  const dt = Date.now() - touchStartTime;
  if (adx < 10 && ady < 10 && dt < 200) {
    playerRotate(1); // tap rotate
  } else if (adx > ady) {
    if (dx > 0) playerMove(1);
    else playerMove(-1);
  } else {
    if (dy > 30) {
      playerDrop(); // swipe down hard drop
    }
  }
}, {passive:false});
</script>
</body>
</html>
